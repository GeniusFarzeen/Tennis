<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ZynPlay — Floating Bat</title>
<style>
  :root{
    --bg:#bfe9ff;
    --court:#e6f7ff;
    --bat:#062f4f;
    --shuttle:#ffefc2;
    --ui:#083d5b;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;}
  body{background:linear-gradient(180deg,var(--bg),#9fdcf6);display:flex;align-items:center;justify-content:center;}
  #game-wrap{position:relative;width:100%;max-width:960px;height:600px;background:var(--court);border-radius:14px;box-shadow:0 10px 30px rgba(3,35,60,0.18);overflow:hidden;}
  canvas{display:block;width:100%;height:100%;}
  #ui{position:absolute;left:12px;top:12px;color:var(--ui);font-weight:700;display:flex;gap:12px;align-items:center;}
  #score{font-size:18px;background:rgba(255,255,255,0.6);padding:6px 10px;border-radius:8px;}
  #msg{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center;display:none;}
  #msg h2{margin:0 0 12px 0;color:var(--ui);font-size:28px;}
  #playAgain{background:var(--ui);color:white;border:none;padding:10px 18px;border-radius:10px;font-size:16px;cursor:pointer;}
  #help{position:absolute;right:12px;top:12px;background:rgba(255,255,255,0.7);padding:8px 10px;border-radius:8px;font-size:13px;color:var(--ui);}
  @media(max-width:600px){
    #game-wrap{height:520px;}
    #msg h2{font-size:20px;}
  }
</style>
</head>
<body>
  <div id="game-wrap">
    <canvas id="c"></canvas>
    <div id="ui"><div id="score">Score: 0</div></div>
    <div id="help">Move bat: drag / touch / mouse / ↑↓ or W S</div>
    <div id="msg">
      <h2 id="statusText">Game Over</h2>
      <button id="playAgain">Play Again</button>
    </div>
  </div>

<script>
document.addEventListener("DOMContentLoaded", ()=>{

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  const wrap = document.getElementById('game-wrap');
  const scoreEl = document.getElementById('score');
  const msg = document.getElementById('msg');
  const playBtn = document.getElementById('playAgain');
  const statusText = document.getElementById('statusText');

  // sizing
  function resize(){
    canvas.width = wrap.clientWidth;
    canvas.height = wrap.clientHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // game state
  let bat, shuttle, score, running, lastTime, speedMultiplier;

  function resetGame(){
    score = 0;
    speedMultiplier = 1;
    running = true;
    msg.style.display = 'none';
    // Bat — floating
    bat = {
      x: canvas.width*0.15,         // fixed x
      y: canvas.height*0.5,        // user controlled y center
      width: 140,
      height: 24,
      bobPhase: 0,
      bobAmp: 12,                  // floating amplitude
      color: '#062f4f'
    };
    // Shuttle comes from right
    shuttle = {
      x: canvas.width - 40,
      y: canvas.height * 0.45,
      vx: -4 * speedMultiplier,
      vy: -2,
      w: 18,
      h: 24,
      alive: true
    };
    lastTime = performance.now();
    scoreEl.innerText = 'Score: 0';
  }

  // input
  let pointerY = null;
  function setPointer(y){
    pointerY = y;
  }
  canvas.addEventListener('mousemove', e => setPointer(e.clientY - canvas.getBoundingClientRect().top));
  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    setPointer(e.touches[0].clientY - canvas.getBoundingClientRect().top);
  }, {passive:false});
  canvas.addEventListener('touchstart', e=> {
    e.preventDefault();
    setPointer(e.touches[0].clientY - canvas.getBoundingClientRect().top);
  }, {passive:false});
  canvas.addEventListener('mousedown', e => setPointer(e.clientY - canvas.getBoundingClientRect().top));
  document.addEventListener('mouseup', ()=> pointerY = null);

  // keyboard
  let up=false, down=false;
  document.addEventListener('keydown', e=>{
    if(e.key==='ArrowUp' || e.key==='w' || e.key==='W') up=true;
    if(e.key==='ArrowDown' || e.key==='s' || e.key==='S') down=true;
  });
  document.addEventListener('keyup', e=>{
    if(e.key==='ArrowUp' || e.key==='w' || e.key==='W') up=false;
    if(e.key==='ArrowDown' || e.key==='s' || e.key==='S') down=false;
  });

  // basic circle-triangle collision helper
  function rectIntersects(x,y,w,h, rx,ry,rw,rh){
    return !(x+w < rx || x > rx+rw || y+h < ry || y > ry+rh);
  }

  // draw functions
  function drawBackground(){
    // simple gradient sky + ground stripe
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, '#bfe9ff');
    g.addColorStop(0.6, '#e6f7ff');
    g.addColorStop(1, '#c6eefc');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // subtle horizon line
    ctx.fillStyle = '#cdeefc';
    ctx.fillRect(0, canvas.height*0.68, canvas.width, canvas.height*0.32);
  }

  function drawBat(){
    // draw a sleek floating bat — rounded rectangle + highlight
    const x = bat.x;
    const y = bat.y - bat.height/2 + Math.sin(bat.bobPhase)*bat.bobAmp;
    const w = bat.width;
    const h = bat.height;
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.fillRect(x + 6, y + h + 6, w - 20, 6);
    // body
    ctx.fillStyle = bat.color;
    roundRect(ctx, x, y, w, h, 10, true, false);
    // highlight bar
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    roundRect(ctx, x + 8, y + 4, w - 16, h/2.6, 8, true, false);
  }

  function drawShuttle(){
    ctx.save();
    // shuttle is a small top-down/side-like stylized triangle + feathers
    ctx.translate(shuttle.x, shuttle.y);
    const angle = Math.atan2(shuttle.vy, shuttle.vx);
    ctx.rotate(angle);
    // body
    ctx.fillStyle = '#ffefc2';
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(-shuttle.w, -shuttle.h/2);
    ctx.lineTo(-shuttle.w, shuttle.h/2);
    ctx.closePath();
    ctx.fill();
    // tail/feathers
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(-shuttle.w - 6, -shuttle.h/4, 6, shuttle.h/2);
    ctx.restore();
  }

  // utility: rounded rect
  function roundRect(ctx,x,y,w,h,r,fill,stroke){
    if (typeof r === 'undefined') r = 5;
    if (typeof stroke === 'undefined') stroke = true;
    if (typeof fill === 'undefined') fill = true;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // hit detection between shuttle and bat (simpler): bounding box + small padding
  function checkHit(){
    const batTop = bat.y - bat.height/2 + Math.sin(bat.bobPhase)*bat.bobAmp;
    const batRect = {x: bat.x, y: batTop, w: bat.width, h: bat.height};
    const shRect = {x: shuttle.x - shuttle.w, y: shuttle.y - shuttle.h/2, w: shuttle.w, h: shuttle.h};
    return rectIntersects(batRect.x, batRect.y, batRect.w, batRect.h, shRect.x, shRect.y, shRect.w, shRect.h);
  }

  // main loop
  function loop(now){
    if(!running) return;

    const dt = Math.min(40, now - lastTime);
    lastTime = now;

    // update bat bob
    bat.bobPhase += 0.02 * (dt/16);
    // pointer or keys move bat
    if(pointerY !== null){
      // smooth follow pointer
      bat.y += (pointerY - bat.y) * 0.18;
    } else {
      if(up) bat.y -= 4;
      if(down) bat.y += 4;
      // clamp
    }
    bat.y = Math.max(40, Math.min(canvas.height - 40, bat.y));

    // update shuttle physics
    shuttle.x += shuttle.vx * (dt/16);
    shuttle.y += shuttle.vy * (dt/16);
    // gravity-like small effect
    shuttle.vy += 0.06 * (dt/16);

    // bounce top/bottom
    if(shuttle.y < 20){ shuttle.y = 20; shuttle.vy *= -0.6; }
    if(shuttle.y > canvas.height - 20){ shuttle.y = canvas.height - 20; shuttle.vy *= -0.6; }

    // check hit
    if(shuttle.vx < 0 && checkHit()){
      // hit — reflect and add spin based on where it hit the bat
      const hitY = shuttle.y - (bat.y + Math.sin(bat.bobPhase)*bat.bobAmp);
      const norm = hitY / (bat.height/2);
      shuttle.vx = -shuttle.vx * 1.06; // increase speed slightly
      shuttle.vy = norm * 5; // send up or down
      score++;
      scoreEl.innerText = 'Score: ' + score;
      // small nudge to avoid duplicate collision
      shuttle.x = bat.x + bat.width + 4;
      // slight difficulty increase over time
      speedMultiplier += 0.005;
    }

    // if shuttle reaches left edge (miss), game over
    if(shuttle.x < -40){
      running = false;
      // show msg
      statusText.innerText = `Game Over — Score ${score}`;
      msg.style.display = 'block';
      return;
    }

    // if shuttle passes right edge, respawn going left (keeps game running)
    if(shuttle.x > canvas.width + 40){
      shuttle.x = canvas.width - 80;
      shuttle.vx = -4 * (1 + score*0.02);
      shuttle.vy = (Math.random()-0.5)*2;
    }

    // draw
    drawBackground();
    drawBat();
    drawShuttle();

    requestAnimationFrame(loop);
  }

  // play again handler
  playBtn.addEventListener('click', ()=>{
    resetGame();
    lastTime = performance.now();
    requestAnimationFrame(loop);
  });

  // start
  resetGame();
  lastTime = performance.now();
  requestAnimationFrame(loop);

}); // DOMContentLoaded
</script>
</body>
</html>
